<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
            <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-89717266-1"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-89717266-1');
        </script>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
        <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/styles/a11y-dark.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js"></script>
        <link href="/css/base.css" rel="stylesheet">

        <title>Understanding D3</title>
    <link href="/css/blog.css" rel="stylesheet"></head>
    <body>
        <div class="content">
        <nav>
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/blog">Blog</a></li>
            </ul> 
        </nav>
        
<article>
    <h1 class="title">Understanding D3</h1>
    <blockquote>
<p>This is a first draft. I will likely revise (multiple times) in the future
for clarity. But hopefully, even in its current state, you might find this
useful.</p>
</blockquote>
<section><h2>Table of Contents</h2><ul>
<li><a href="#the-strange-case-of-d3">The strange case of D3</a></li>
<li><a href="#the-big-idea-and-why-its-so-hard">The big idea (and why it's so hard)</a></li>
<li><a href="#lets-start-with-just-a-line">Let's start with just a line</a>
<ul>
<li><a href="#set-up">Set up</a></li>
<li><a href="#the-code">The Code</a>
<ul>
<li><a href="#elements">Elements</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#data">Data</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#why-this-way">Why this way?</a></li>
</ul></section>
<section><h2>The strange case of D3</h2><p>Dr. Jekyll: D3 is famous for being an incredibly versatile visualization
library.</p><p>Mr. Hyde: D3 is <em>infamous</em> for having a steep learning curve and being difficult
to understand past copy and pasting examples.</p><p>I have experienced the dark side of D3, but recently, I feel as if I have had
minor breakthrough, so hopefully I can in turn provide you with some sort of
lightbulb moment.</p><p>But just as a disclaimer: in no way do I profess to be an expert (or anywhere
close). I've still a lot to learn. I just think something clicked for me.</p></section>
<section><h2>The big idea (and why it's so hard)</h2><p>Having gained some understanding, I now know this is the mantra you must repeat
to yourself.</p><blockquote>
<p>D3 gives you <strong>functions</strong> to work with <strong>data</strong> bound to <strong>elements</strong>.</p>
</blockquote><p>Does that sound kind of familiar? It probably should. Here's the first sentence
on the D3 website.</p><blockquote>
<p>D3.js is a JavaScript library for manipulating documents based on data</p>
</blockquote><p>and later on...</p><blockquote>
<p>D3 allows you to bind arbitrary data to a Document Object Model (DOM), and
then apply data-driven transformations to the document</p>
</blockquote><p>That leads me to believe D3 is difficult to learn because it relies on a very
simple and powerful concept -- too simple to warrant understanding when just
starting out and too powerful to appreciate without building and seeing lots of
examples.</p></section>
<section><h2>Let's start with just a line</h2><p>We will begin with the three basic parts to working with D3. We will have an
element in the DOM (element). We will have some data, with which we'll draw a
line (data). And we'll use D3 to put those things together (functions).</p><p>D3 has a lot of conventions. These are useful to learn as a stepping stone to
learning the concepts, so I will try to use a few of them here.</p><p>This is what the result looks like.</p><script src="https://d3js.org/d3.v5.min.js"></script><style>
    svg {
        position: relative;
        left: 50%;
        transform: translateX(-50%);
    }
</style><script>
function draw () {
    // Data
    const X = [1, 2, 3, 4, 5];
    const Y = [3, 5, 1, 6, 9];
    const data = X.map((x, i) => [x, Y[i]]);

    // Set sizes
    let width = 600;
    let height = 300;
    let margin = {top: 5, right: 0, bottom: 30, left: 30};

    // Create functions
    let xScale = d3.scaleLinear()
                    .domain(d3.extent(data.map(d => d[0])))
                    .range([0, width - margin.left - margin.right]);
    let yScale = d3.scaleLinear()
                    .domain(d3.extent(data.map(d => d[1])))
                    .range([height - margin.top - margin.bottom, 0]);
    let line = d3.line().x(d => xScale(d[0])).y(d => yScale(d[1]));
    let xAxis = d3.axisBottom().scale(xScale);
    let yAxis = d3.axisLeft().scale(yScale);

    // Create elements
    let svg = d3.select("figure.example > svg")
        .attr("width", width)
        .attr("height", height)

    let chart = svg.append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`);
    let chart__line = chart.append("path")
        .attr("fill", "none")
        .attr("stroke", "black");
    let chart__xaxis = chart.append("g")
        .attr("class", "g__xaxis")
        .attr("transform", `translate(0, ${height - margin.top - margin.bottom})`);
    let chart__yaxis = chart.append("g")
        .attr("class", "g__yaxis")

    // Bind data and call functions
    chart__line.datum(data)
        .attr("d", line);

    chart__xaxis.call(xAxis);
    chart__yaxis.call(yAxis);
}
window.onload = draw;
</script><figure class="example">
<h2 class="figure__title">Figure: Just a Line Plot</h2>
<svg>
</svg>
</figure><h3>Set up</h3><p>Let's start with the easiest part to set up: the DOM. This is all the HTML I
have:</p><pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">figure</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"example"</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"figure__title"</span>></span>Figure: Just a Line Plot<span class="hljs-tag">&#x3C;/<span class="hljs-name">h2</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">svg</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">svg</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">figure</span>></span>
</code></pre><p>We have a simple dataset (5 points to form a line).</p><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> X = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> Y = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>];
</code></pre><p>Again, nothing special.</p><h3>The Code</h3><p>This is the interesting part, but don't be intimidated. In fact, this chart is
made with only 16 lines of actual code.</p><p>First, let's define some variables we want to keep track of:</p><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> width = <span class="hljs-number">600</span>;
<span class="hljs-keyword">let</span> height = <span class="hljs-number">300</span>;
<span class="hljs-comment">// this is the margin convention</span>
<span class="hljs-keyword">let</span> margin = {<span class="hljs-attr">top</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">right</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">bottom</span>: <span class="hljs-number">30</span>, <span class="hljs-attr">left</span>: <span class="hljs-number">30</span>};
</code></pre><p>Remember our mantra: data, function, elements. Again, let's start with elements.</p><h4>Elements</h4><pre><code class="hljs language-js"><span class="hljs-comment">// Create elements</span>
<span class="hljs-comment">// select SVG</span>
<span class="hljs-keyword">let</span> svg = d3.select(<span class="hljs-string">"figure.example > svg"</span>)
    .attr(<span class="hljs-string">"width"</span>, width)
    .attr(<span class="hljs-string">"height"</span>, height)

<span class="hljs-comment">// create chart</span>
<span class="hljs-keyword">let</span> chart = svg.append(<span class="hljs-string">"g"</span>)
    .attr(<span class="hljs-string">"transform"</span>, <span class="hljs-string">`translate(<span class="hljs-subst">${margin.left}</span>, <span class="hljs-subst">${margin.top}</span>)`</span>);
<span class="hljs-keyword">let</span> chart__line = chart.append(<span class="hljs-string">"path"</span>)
    .attr(<span class="hljs-string">"fill"</span>, <span class="hljs-string">"none"</span>)
    .attr(<span class="hljs-string">"stroke"</span>, <span class="hljs-string">"black"</span>);
<span class="hljs-keyword">let</span> chart__xaxis = chart.append(<span class="hljs-string">"g"</span>)
    .attr(<span class="hljs-string">"class"</span>, <span class="hljs-string">"g__xaxis"</span>)
    .attr(<span class="hljs-string">"transform"</span>, <span class="hljs-string">`translate(0, <span class="hljs-subst">${height - margin.top - margin.bottom}</span>)`</span>);
<span class="hljs-keyword">let</span> chart__yaxis = chart.append(<span class="hljs-string">"g"</span>)
    .attr(<span class="hljs-string">"class"</span>, <span class="hljs-string">"g__yaxis"</span>)
</code></pre><p>I won't go too far into the details here, but the basic idea is we create all of
our chart elements under a single "chart" group. This has to do with the
convention of defining a size for the SVG, defining margins, and adjusting the
size of your "canvas" accordingly.</p><p>I want to stress that this <em>sets up</em> our chart, but we've yet to actually draw
anything. We have added the <strong>elements</strong>, but we haven't set up any functions or
bound any data. So let's do some of that now.</p><h4>Functions</h4><pre><code class="hljs language-js"><span class="hljs-comment">// Create functions</span>
<span class="hljs-keyword">let</span> xScale = d3.scaleLinear()
                .domain(d3.extent(data.map(<span class="hljs-function"><span class="hljs-params">d</span> =></span> d[<span class="hljs-number">0</span>])))
                .range([<span class="hljs-number">0</span>, width - margin.left - margin.right]);
<span class="hljs-keyword">let</span> yScale = d3.scaleLinear()
                .domain(d3.extent(data.map(<span class="hljs-function"><span class="hljs-params">d</span> =></span> d[<span class="hljs-number">1</span>])))
                .range([height - margin.top - margin.bottom, <span class="hljs-number">0</span>]);
<span class="hljs-keyword">let</span> line = d3.line().x(<span class="hljs-function"><span class="hljs-params">d</span> =></span> xScale(d[<span class="hljs-number">0</span>])).y(<span class="hljs-function"><span class="hljs-params">d</span> =></span> yScale(d[<span class="hljs-number">1</span>]));
<span class="hljs-keyword">let</span> xAxis = d3.axisBottom().scale(xScale);
<span class="hljs-keyword">let</span> yAxis = d3.axisLeft().scale(yScale);
</code></pre><p>Here, we set up our scales, axes, as well as the line generator. This doesn't
draw anything either, because we've yet to put the functions and elements
together. Luckily for us, that step is pretty easy.</p><h4>Data</h4><pre><code class="hljs language-js"><span class="hljs-comment">// Bind data and call functions</span>
chart__line.datum(data)
    .attr(<span class="hljs-string">"d"</span>, line);

chart__xaxis.call(xAxis);
chart__yaxis.call(yAxis);
</code></pre><p>I want to focus on two things here. First, notice how we now bind our data to
the <code>chart__line</code> element. We use <code>datum</code> because we are drawing one line, so
we're binding this one piece of data (singular: datum). Now, when we set the <code>d</code>
attribute, we can pass in a function that takes the datum (our array of
coordinates) as input and returns the line path as output.</p><p>Second, notice how we're drawing the axes. We set up the <code>xAxis</code> and <code>yAxis</code>
functions earlier, and the <code>.call</code> is essentially passing our selection as input
to the function. It's equivalent to <code>xAxis(chart__xaxis)</code>, for example, so don't
let the syntax scare you.</p><p>Using <code>.call</code> is convenient for chaining functions, and this pattern is
recommended for creating reusable charts. The idea is you can have a selection
of <code>svg</code>s with bound data, call your chart on that selection, and draw charts
using the bound data for each element in your selection.</p></section>
<section><h2>Why this way?</h2><p>It's possible to create D3 graphics without following this pattern. I'd bet most
people (myself included) did not start creating graphics with this pattern. So
why take the extra effort to learn and implement these ideas?</p><p>There are a couple of reasons which go hand-in-hand.</p><ol>
<li>This is the way D3 was designed to be used.<label for="1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="1" class="margin-toggle"><span class="sidenote">I will qualify this statement by saying that, since I didn't design D3, technically I don't know if this is true. That said, having read a lot of Mike Bostock's (and others') writing on best practices for D3, this seems to be the "right way"</span></li>
<li>Because of this, when you implement things this way, things are more likely
to "just work".</li>
<li>Also because of this, debugging becomes easier because you're not trying to
resolve any conflicts between your mental model and the model D3 adopts.</li>
</ol><p>I'll provide an example of how you might be tempted to do things, and how those
end up causing headaches later on. The tl;dr is that problems arise when you
don't separating elements, data, and functions effectively.</p><p>In the past, I used to do this a lot:</p><pre><code class="hljs language-js"><span class="hljs-comment">// draw axes</span>
g.append(<span class="hljs-string">"path"</span>).datum(data).attr(<span class="hljs-string">"d"</span>, line)
g.append(<span class="hljs-string">"g"</span>).call(xAxis)
g.append(<span class="hljs-string">"g"</span>).call(yAxis)
</code></pre><p><strong>Why is this bad?</strong> We don't save our selections, and you can think of this as
treating the <code>path</code> element as bound to this specific <code>datum</code>.</p><p><strong>What does that mean?</strong> If we want to change our data, we will update <code>data</code>
and run that code again, but since we don't keep a pointer to the <code>path</code>
element, we end up just appending another path. Instead of redrawing the line,
we draw a new line. Additionally, if we wanted our graphic to be responsive
(that is, resize when the browser window resizes), we need to update and redraw
our axes. That means we should also keep pointer to the axes elements.</p><p><strong>Moral of the story?</strong> Set up your elements once, then use D3 functions to bind
data and draw many times. Since you're not creating a new element every update,
D3 can keep track of the current bound data and update accordingly. This also
lets you use D3 transitions more easily.</p></section>
</article>

        </div>
    </body>
</html>
